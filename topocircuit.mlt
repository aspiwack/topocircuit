open Prelude

let codemode = Melt.Verbatim.convert (fun x -> x |> Latex.Verbatim.verbatim |> Latex.textsf)

##verbatim '%' = MathPlugin.mathmode
##verbatim '#' = codemode
(* arnaud: bind '#' on a Faust mode, at least an sf verbatim mode. *)

(*** Holes ***)

let citation_needed = small"[?]"
let ref_needed = small"[?]"
let diagram_needed = small"[diagram]"

(*** labels ***)

let d_bhdomain = label ()
let t_bhfixpoint = label ()
let r_omegacpos = label ()
let s_sequentialcircuits = label ()

(*** Document ***)
let abstract = "Leveraging topos theory a semantics can be given to sequential circuits where time-sensitive gates, such as unit delay, are treated uniformly with combinational gates. Both kinds of gates are functions in a particular topos: the topos of presheaves over the natural ordering of <%bbN%>. This is used to show that sequential circuits validate the equational theory of traced categories."

let abstract =
  environment \"abstract\" (T,abstract) T

let intro = "
When giving semantics to circuits (typically boolean circuits), it is customary to treat the combinational~--~{foreign"i.e."} time-independent~--~parts of the circuits differently from time sensitive ones. Since it is usually assumed that the only time-sensitive gate is the unit delay, each outgoing wire from a delay is considered an additional input, and each incoming wire an additional output. Some care is taken to feed the right output into the right input at next iteration, and so time-sensitivity is eliminated and one can reason on a purely combinational circuit.

This is not very convenient to reason equationally about moving unit delays for better placement. But this approach really breaks down when considering time-sensitive gates which are not simple unit delay. This article takes its root in the study of compilation of the circuit programming language Faust~{cite"Orlarey2004"}. Faust features a somewhat unusual kind of delay gate, written <#s@d#>, where <#s#> is an arbitrary signal, and <#d#> is a {emph"time-varying"} bounded natural number signal whose value at time <%t%> determines how far in the past of <#s#> to fetch the value of the delayed signal.

With such a construct, it becomes impossible to ``cut'' a circuit into a combinational circuit. At least not without heavy modifications (the constraint that <#d#> is bounded is imposed in order to be able to compile the program in constant memory, so such a circuit can be reduced to use only unit delays).

To address this issue, let us turn to presheaves and topos theory. The critical property which we shall use is that topoi are models of constructive mathematics. Therefore we shall first develop a theory of combinational circuits in ordinary constructive mathematics, then lift it to sequential circuits {foreign"via"} a presheaf construction.

Much work has been put~{citation_needed}, recently, in using category theory to explain and exploit the linear algebraic aspects of circuits from control-theory. This article explores an orthogonal axis of the design space. Both can, and should, in principle be combined to obtain linear algebra with time. It is what signal processing is made of.

Before we move on, I have to start with an apology: despite the subject of topoi and presheaves being rather technical, I will be assuming quite a bit of familiarity with them in this article. I realise that this will make this article unnecessarily arduous for many. But in order for this article to be written at all, I felt I had to limit its scope so. A good, exhaustive, introduction to topos theory can be found in Mac Lane \& Moerdijk's {emph"Sheaves in geometry and logic"}~{cite"MacLaneMoerdijk1992"}.

{paragraph"Acknowledgement"}
I was once sitting with Noam Zeilberger listening to a seminar by Gérard Berry. About circuits. Berry's presentation was obviously of great interest to the both of us as we went on discussing its content for quite a while after that. At some point Zeilberger remarked: ``I don't really know what a circuit {emph"is"}'', and I suddenly realised that I didn't quite either; despite the intuitive, and occasionally concrete, nature of circuits. If Zeilberger's remark gave you pause, as it did to me, then read on for my attempt at a definition.
"

let combinational = "{chapter"Combinational circuits"}

It is direct to give a definition of combinational circuits if they are not allowed to have loops: just interpret each gate as a function a compose things appropriately. Or, more generally, if you are so disposed, interpret each gate as an arrow in some cartesian category, and interpret appropriately.

The case that drove my interest, however, requires loops~--~aka feedback. I am not particularly in need of delay-free loops, although this is of legitimate interest (see for instance~{cite"Mendler2012"}), but the semantics which is developed in this section will be lifted in Section~{ref_ s_sequentialcircuits} to sequential circuits which are useless without some form of feedback.

{section"Constructive domain semantics"}

As good computer scientist ought to when faced with tricky fixed point (even in circuits, loops are, after all, fixed points), let us turn to domains. Before we give a formal description of our semantics, let me note that it is a straightforward variant of the rather venerable {emph"three-valued semantics"} of combinational boolean circuits~{cite"Malik1993"}, which, by the way, has been shown, with {foreign"caveats"}, to be a good semantics for electronic circuits~{cite"Mendler2012"}.

Boolean circuits have, of course, a special relevance in computing science due to their being the basic building block of computers. But we will not restrict ourselves so. Wires will be allowed to carry values of any type we wish. The Faust programming language, for instance, has wires of type <%bbN%> and <%bbR%> (floating point numbers, in practice). The types, which, for the purpose of this article, are simply sets of permitted values, allowed for the wires by a circuit language will be called {emph"base types"}.

{definition ~label:d_bhdomain ~name:"Bounded height domain"
    "A bounded height domain is a partially ordered set <%D%> equipped with a number <%b%> such that every increasing chain <%x_1 LEQ %{ldots}% LEQ x_n%> in <%D%> with <%n GT b%> has a pair <%x_i GEQ x_j%> with <%i LT j%> (equivalently, for every <%i LEQ k LEQ j%>, <%x_i = x_k%>)."}

Circuits will be given a semantics as increasing functions between such domains. To the extent that the material present in this section is different from the usual treatment it is to render this section constructive to be compatible with the topos of Section~{ref_needed}. This is the reason why we focus on bounded height domains rather than the more usual <%omega%>-{textsc"cpo"}s. Note also that <%b%>, in Definition~{ref_ d_bhdomain} is {emph"not"} the height of the domain but rather an upper bound on this height. The reason is that, constructively, there may not be an exact height (see also~{cite"CoquandSpiwack2010"} for more thoughts on finiteness in constructive mathematics). Every proof, in this section, is constructive.

Bounded height domain have the fixed-point property, just like other kinds of domains. Note that the fixed-point property of {textsc"cpo"}s or <%omega%>-{textsc"cpo"}s are also constructive. The added value of bounded height domains is that there are really few constructive {textsc"cpo"}s or <%omega%>-{textsc"cpo"}s (see Remark~{ref_ r_omegacpos} below).

{theorem ~name:"Fixed-point property" ~label:t_bhfixpoint
    "Every increasing function <%f:D->D%> for a bounded height domain <%D%> with a smallest element <%Bot%> has a smallest fixed-point."
      ~proof:"Let <%b%> be a bound on the height of <%D%>. The sequence <%Bot LEQ f Bot LEQ f^2 Bot LEQ %{ldots}% LEQ f^b Bot%> has length <%b+1%>. By definition, there is an <%i LT b%> such that <%f^i Bot = f^\(i+1\) Bot%> hence <%f^b Bot = f^i Bot%> is a fixed point.

  It is the smallest since, by induction, for any fixed point <%x_0%> of <%f%> and every <%k%>, <%f^k Bot LEQ x_0%>.  "}

Remark that we can refine the proof to show that the least fixed point of <%f%> is also its least pre-fixed point ({foreign"i.e."} such that <%f x LEQ x%>).

Base types, which are sets, can be naturally identified to bounded height domains (without a smallest element).

{definition ~name:"Flat domains"
    "Given a set <%A%>, the partially ordered set (also noted <%A%>) where <%x LEQ y <=> x=y%> is a domain of height bounded by <%1%>, which we call a flat domain."}

Continuing on the subject of constructiveness, notice that flat domains are an example of domain which can't be assigned a height. Indeed, if <%A%> is inhabited then <%A%> has height <%1%>, whereas when <%A%> is empty then <%A%> has height <%0%> but it is not possible, in constructive mathematics to decide whether <%A%> is empty or not, the height flat domains is, therefore, not well defined (it is, in fact, impossible to define a non-constant integer-valued function on sets~{cite"Escardo2013"}).

In order to use base types in conjunction with the fixed point property they need a smallest element which we add freely.

{definition ~name:"Lifted domains"
    "Given a domain <%A%> with a bound <%b%> on its height, we construct a domain <%A_Bot%>, called {emph"lifted"}, by adding a distinguished element <%Bot%> to <%A%> and considering it smaller than every element of <%A%>: <%forall x:A, Bot LT x%>. The height of <%A_Bot%> is bounded by <%b+1%>"}

Wires in circuits will be interpreted as taking value in the lifted flat domains corresponding to base types. Increasing functions between lifted flat domain are such that if <%f Bot <> Bot%>, then for any <%a%>, <%f a = f Bot%>. In particular, if <%f%> is such a function with several fixed points, then <%f Bot = Bot%> and the smallest fixed point is <%Bot%>. So <%Bot%> represents both the absence of a well-defined fixed point and the presence of several fixed points.

Obviously, in order for the smallest fixed point of<%f%> to be non-<%Bot%>, <%f%> needs to ignore some of its input wires, for instance <%f%> could be the well-know parallel or:

{array [`C;`Vert;`C;`C;`C] [
  array_line ["<%por%>";"<%Bot%>";"<%0%>";"<%1%>"];
  midrule;
  array_line ["<%Bot%>" ; "<%Bot%>";"<%Bot%>";"<%1%>"];
  array_line ["<%0%>" ; "<%Bot%>";"<%0%>";"<%1%>"];
  array_line ["<%1%>" ; "<%1%>";"<%1%>";"<%1%>"];
]}

When one of the input of the parallel or is <%1%>, then the output is <%1%>, whatever the behaviour of the other input. In particular the following circuit is well defined (it outputs <%1%>):

{diagram_needed}

{remark ~label:r_omegacpos
    "Lifted flat domains are an example of bounded-height domains which are not necessarily {omega}-{textsc"cpo"}s, constructively. Indeed consider <%b1 = {0}%>, the singleton set, then <%b1_Bot%> is not constructively an {omega}-{textsc"cpo"}. An {omega}-chain in <%b1_Bot%> is an infinite sequence of <%Bot%> and <%0%> (such that after a <%0%>, every element is <%0%>). If an {omega}-chain has <%Bot%> as an upper bound, then all of its elements are <%Bot%>, if an {omega}-chain has <%0%> as an upper bound, at least one of its elements must be <%0%>{footnote"Purists may noticed that I have made use of Markov's principle in this statement: it's a valid thing to do, though since if something is unprovable from Markov's principle, it is certainly unprovable without. Alternatively, ``must'' in that sentence can be interpreted as the double-negation modality, in which case the statement is constructively true, and leads to a weaker, still non-constructive, version of the limited principle of omniscience."}. If every {omega}-chain had an upper bound, it would give a way to decide whether they contain a <%0%> or not, which is equivalent to the limited principle of omniscience: a known-to-be-non-constructive principle."}

To formalise circuits with multiple wires we remark that bounded height domains are closed by cartesian products.

{lemma ~name:"Cartesian product of domains"
    "The product <%A*B%> of two bounded height domains of respective bound <%b_A%> and <%b_B%>, with order <%(x_1,y_1) LEQ (x_2,y_2) <=> x_1 LEQ x_2 /\ y_1 LEQ y_2%> , is a domain whose height is bounded by <%b_A*b_B%>."
      ~proof:"A chain in <%A*B%> is simply a list of pairs <%(x,y)%>, with an constraint on consecutive pairs. However, chains can be represented differently as a list of pairs <%(x,l)%> with <%l%> a chain in <%B%>, with the intent that the pair <%(x,[y_1,%{ldots}%,y_n])%> represents the chain <%(x,y_1) LEQ %{ldots}% LEQ (x,y_n)%>. So that chains now have multiple representations depending on how successive pairs with the same first component are ``contracted''.

  We begin with the simplest representation where every pair <%(x,l)%> is an <%(x,[y])%>. Now, as long as our list is of size longer than <%b_A%> (without loss of generality we can suppose both <%b_A%> and <%b_B%> to be non-zero) we can use the fact that the first components describe a chain to find consecutive positions with the same <%x%> which we can contract. Hence strictly reducing the size of our list. This process gives us a contracted representation of the long chain of length <%b_A%> or less. But, since the total length of the chain is larger than <%b_A*b_B%>, there must be at least one second-component list with length larger than <%b_B%>. Applying the definition of the bound <%b_B%> to this list concludes the proof."}

Combinational gates are, therefore, interpreted as increasing functions of type <%A_1_Bot*%{ldots}%*A_n_Bot -> A_\(n+1\)_Bot*%{ldots}%*A_p_Bot%> (with each <%A_i%> being a base type). We call a gate <%g%> {emph"strict"} if it for any <%(x_1,%{ldots}%,x_n)%> where at least one of the <%x_i%> is <%Bot%> then <%g x_1%{ldots}% x_n = (y_1,%{ldots}%,y_p)%> where at least one of the <%y_i%> is <%Bot%>.

{section"Traced category"}

What is left is to use the fixed-point property to make precise the definition of feedback wires, the solution is given by Hasegawa~{cite"Hasegawa1997"~extra:"Theorem 3.1"} who gives a method to transform fixed-point operators into traces.

Traced categories~{citation_needed} provide a graphical language which is essentially the same as circuits with feedback. It is reassuring that circuits can be interpreted as arrows in such a traced category. It provides a natural equational theory on circuits which can be, among other things, leveraged to produce compilation schemes~{citation_needed}.

{lemma ~name:"Local fixed-point property"
    "Theorem~{ref_ t_bhfixpoint} can be extended to produce a local fixed point function: let <%f:A*X->X%> an increasing function (<%A%> and <%X%> bounded height domain with a smallest element), there is an increasing function <%mu f:A->X%>, such that for any <%a:A%>, <%\(mu f\) a%> is the least fixed point of the increasing function <%lambda x, f a x%>."
      ~proof:"The proof bulk of the proof is the same as Theorem {ref_ t_bhfixpoint}, taking into account that, by definition of cartesian product <%lambda x, f a x%> is, indeed, increasing: let <%b%> a bound on the height of X,
  <%\(mu f\) a = (lambda x, f a x)^b Bot%>.

We need to check the <%mu f%> is indeed increasing. But since <%f%> is increasing, for any <%a LEQ a'%> and any <%x LEQ x'%>  <%f a x LEQ f a' x'%>; by induction, we conclude that <%\(mu f\) a LEQ \(mu f\) a'%>."}

Hasegawa tells us that there are three properties to verify for a fixed point operator to yield a trace (note that, reciprocally, all traces in a cartesian category yield such a fixed point operator). We shall write <%MU a x, f a x%> instead of <%mu\(lambda (a,x), f a x\)%>. In addition and by definition, <%(MU a x, f a x) a_0 = MU x, f a_0 x%>; since the former is cumbersome, we will use the latter as a short-hand.

{lemma ~name:"Naturality in <%A%>"
  "For any <%f:A*X->X%> and <%g:B->A%>, the following holds: <%MU b x, f\(g b\) x = \(mu f\) COMP g%>."
  ~proof:"Let <%b:B%>, <%(MU b x, f\(g b\) x) b = MU x, f\(g b\) x%> is, by definition, the least fixed point of <%lambda x, f \(g b\) x%>. And, also by definition, so is <%\(mu f\) \(g b\)%>."}

{lemma ~name:"Naturality in <%X%>"
  "Let <%f%> be an increasing function in <%A*X->Y%>. For any <%g:Y->X%>, <%MU a x, g \(f a x\) = g COMP (MU a y, f a \(g y\))%>."
      ~proof:"Let us fix an <%a:A%>.
  {itemize [
    "Let us prove that <%g \(MU y, f a \(g y\)\)%> is a fixed point of <%\(lambda x, g \(f a x\)\)%>, and therefore <%MU x, g \(f a x\) LEQ g \( MU y, f a \(g y\) \)%>. This follows immediately from the fact that <%f a \(g \( MU y, f a \(g y\) \)\) = MU y, f a \(g y\) a%> and the fact that <%g%> is increasing.";
      "Conversely, we prove similarly that <%f a \(MU x, g \(f a x\)\)%> is a fixed point of <%lambda y, f a \(g y\)%>. This yields <%f a \(MU x, g \(f a x\)\) GEQ MU y, f a \(g y\) = f a \(g \( MU y, f a \(g y\) \)\)%>, and then, <%MU x, g \(f a x\) GEQ g \( MU y, f a \(g y\) \)%> by monotonicity of <%lambda x, f a x%>."
  ]}

  The two inequalities prove the lemma."}

{let inner = "<%MU x, f a x \(\(mu g\) a x\)%>" in
lemma ~name:"Bekič"
  "Let <%f:A*X*Y->X%> and <%g:A*X*Y->Y%>. Taking <%h:A->X%> to be <%h a = %{inner}%%>, the following holds <%MU a (x,y), (f a x y, g a x y) = lambda a, (h a , \(mu g\) a \(h a\))%>"
    ~proof:"For <%a:A%>, let us prove that <%(h a , \(mu g\) a \(h a\))%> is a fixed point of <%lambda (x,y), (f a x y, g a x y)%>.
  {displaymath @@ array [`L;`L;`L] [
    array_line [empty;"<%(f a \(h a\) \(\(mu g\) a \(h a\)\), g a \(h a\) \(\(mu g\) a \(h a\)\))%>"; empty];
    array_line [$=$;"<%(f a \(h a\) \(\(mu g\) a \(h a\)\), \(mu g\) a \(h a\))%>"; "(definition of <%mu g%>)"];
    array_line [$=$;"<%(h a, \(mu g\) a \(h a\))%>"; "(definition of <%h%>)"];
  ]}

  We also have that
  {displaymath @@ array [`L;`L] [
    array_line [empty;"<%MU (x,y), (f a x y, g a x y)%>"];
    array_line [ $=$; "<%(f a \(MU (x,y), (f a x y, g a x y)\) , g a \(MU (x,y), (f a x y, g a x y)\) )%>"];
  ]}

  This allows us to test both components for being fixed points or the corresponding function, which will suffice to conclude.

  {itemize [
    "<%f a \(MU (x,y), (f a x y, g a x y)\) GEQ h a%>: by definition of <%h%> it suffices to show that <%f a \(MU (x,y), (f a x y, g a x y)\)%> is a pre-fixed point of <%lambda x, f a x \(\(mu g\) (a,x)\)%>. After tedious calculations{footnote"So tedious, in fact, that I ended up formalising most of this section in the Coq proof assistant which, contrary to me, is not susceptible to calculation mistakes. Plus, I was getting lost and could use the help. This goes to prove that for certain mathematical proofs, proof assistant can be a productive way to develop proofs."}, it amounts to proving, calling <%(x_0,y_0) = \(MU (x,y), (f a x y, g a x y)\)%>, that <%MU y, g a x_0 y LEQ y_0%>. It is easily checked that <%y_0%> is a fixed point of <%lambda y, g a x_0 y%>, which concludes this sub-proof.";
    "<%g a \(MU (x,y), (f a x y, g a x y)\) GEQ \(mu g\) a \(h a\)%>. The argument is similar to above.";
  ]}  "}
"

let sequential = "{chapter"Sequential circuits" ~label:s_sequentialcircuits}
"

let packages = [
  "inputenc" , "utf8" ;
  "fontenc" , "T1" ;
  "textcomp", "";
  "microtype" , "" ;
]

let prelude = concat_with_sep [
  (* Mis ici pour rester le plus "en dernier" possible. Plus d'options à mettre
     à l'avenir, en particulier pour configurer le style des liens*)
  command \"usepackage\" [T,"hyperref"] T ;
  input "style.tex";
  command \"bibliographystyle\" [T,"plain"] T;
  declare_theorems;
] par

let title = "Circuits via topoi"
let author = "Arnaud Spiwack"

let titling = concat [
  command \"title\" [T,title] T;
  command \"author\" [T,author] T;
  maketitle;
]

let doc = concat [
  titling;
  abstract;
  intro;
  combinational;
  sequential;
  command \"bibliography\" [A,"library"] A;
]

let file = \"topocircuit.tex\"

let options =
  [ "a4paper" ;
    "article" ;
  ]

let _ =
  try
    emit ~file (document ~options
                         ~prelude
                         ~packages
                         doc)
  with e -> Printexc.print_backtrace stdout; raise e

  (* arnaud: rafiner les modes plus tard *)
let _ =
  Mlpost.Defaults.set_prelude
      \"axhurkens.tex\"

let _ =
  Mlpost.Defaults.set_required_files [
    \"style.tex\"
  ]

let _ = match Arg.mode with
	 | `Cairo -> Mlpost.Cairost.dump_pdf ()
	 | `Mps -> Mlpost.Mps.dump ()
	 | _ -> assert false
