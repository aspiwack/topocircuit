open Prelude

let codemode = Melt.Verbatim.convert (fun x -> x |> Latex.Verbatim.verbatim |> Latex.textsf)

##verbatim '%' = MathPlugin.mathmode
##verbatim '#' = codemode
(* arnaud: bind '#' on a Faust mode, at least an sf verbatim mode. *)

(*** Holes ***)

let citation_needed = small"[?]"
let ref_needed = small"[?]"
let diagram_needed = small"[diagram]"

(*** labels ***)

let s_combinationalcircuits = label ()
let s_trace = label ()
let d_bhdomain = label ()
let t_bhfixpoint = label ()
let r_omegacpos = label ()
let s_sequentialcircuits = label ()

(*** Document ***)
let abstract = "Leveraging topos theory a semantics can be given to sequential circuits where time-sensitive gates, such as unit delay, are treated uniformly with combinational gates. Both kinds of gates are functions in a particular topos: the topos of presheaves over the natural ordering of <%bbN%>. This is used to show that sequential circuits validate the equational theory of traced categories."

let abstract =
  environment \"abstract\" (T,abstract) T

let intro = "
When giving semantics to circuits (typically boolean circuits), it is customary to treat the combinational~--~{foreign"i.e."} time-independent~--~parts of the circuits differently from time sensitive ones. Since it is usually assumed that the only time-sensitive gate is the unit delay, each outgoing wire from a delay is considered an additional input, and each incoming wire an additional output. Some care is taken to feed the right output into the right input at next iteration, and so time-sensitivity is eliminated and one can reason on a purely combinational circuit.

This is not very convenient to reason equationally about moving unit delays for better placement. But this approach really breaks down when considering time-sensitive gates which are not simple unit delay. This article takes its root in the study of compilation of the circuit programming language Faust~{cite"Orlarey2004"}. Faust features a somewhat unusual kind of delay gate, written <#s@d#>, where <#s#> is an arbitrary signal, and <#d#> is a {emph"time-varying"} bounded natural number signal whose value at time <%t%> determines how far in the past of <#s#> to fetch the value of the delayed signal.

With such a construct, it becomes impossible to ``cut'' a circuit into a combinational circuit. At least not without heavy modifications (the constraint that <#d#> is bounded is imposed in order to be able to compile the program in constant memory, so such a circuit can be reduced to use only unit delays).

To address this issue, let us turn to presheaves and topos theory. The critical property which we shall use is that topoi are models of constructive mathematics. Therefore we shall first develop a theory of combinational circuits in ordinary constructive mathematics, then lift it to sequential circuits {foreign"via"} a presheaf construction.

Much work has been put~{citation_needed}, recently, in using category theory to explain and exploit the linear algebraic aspects of circuits from control-theory. This article explores an orthogonal axis of the design space. Both can, and should, in principle be combined to obtain linear algebra with time. It is what signal processing is made of.

Before we move on, I have to start with an apology: despite the subject of topoi and presheaves being rather technical, I will be assuming quite a bit of familiarity with them in this article. I realise that this will make this article unnecessarily arduous for many. But in order for this article to be written at all, I felt I had to limit its scope so. A good, exhaustive, introduction to topos theory can be found in Mac Lane \& Moerdijk's {emph"Sheaves in geometry and logic"}~{cite"MacLaneMoerdijk1992"}.

{paragraph"Acknowledgement"}
I was once sitting with Noam Zeilberger listening to a seminar by Gérard Berry. About circuits. Berry's presentation was obviously of great interest to the both of us as we went on discussing its content for quite a while after that. At some point Zeilberger remarked: ``I don't really know what a circuit {emph"is"}'', and I suddenly realised that I didn't quite either; despite the intuitive, and occasionally concrete, nature of circuits. If Zeilberger's remark gave you pause, as it did to me, then read on for my attempt at a definition.
"

let combinational = "{chapter"Combinational circuits" ~label:s_combinationalcircuits}

It is direct to give a definition of combinational circuits if they are not allowed to have loops: just interpret each gate as a function a compose things appropriately. Or, more generally, if you are so disposed, interpret each gate as an arrow in some cartesian category, and interpret appropriately.

The case that drove my interest, however, requires loops~--~aka feedback. I am not particularly in need of delay-free loops, although this is of legitimate interest (see for instance~{cite"Mendler2012"}), but the semantics which is developed in this section will be lifted in Section~{ref_ s_sequentialcircuits} to sequential circuits which are useless without some form of feedback.

{section"Constructive domain semantics"}

As good computer scientist ought to when faced with tricky fixed point (even in circuits, loops are, after all, fixed points), let us turn to domains. Before we give a formal description of our semantics, let me note that it is a straightforward variant of the rather venerable {emph"three-valued semantics"} of combinational boolean circuits~{cite"Malik1993"}, which, by the way, has been shown, with {foreign"caveats"}, to be a good semantics for electronic circuits~{cite"Mendler2012"}.

Boolean circuits have, of course, a special relevance in computing science due to their being the basic building block of computers. But we will not restrict ourselves so. Wires will be allowed to carry values of any type we wish. The Faust programming language, for instance, has wires of type <%bbN%> and <%bbR%> (floating point numbers, in practice). The types, which, for the purpose of this article, are simply sets of permitted values, allowed for the wires by a circuit language will be called {emph"base types"}.

{definition ~label:d_bhdomain ~name:"Bounded height domain"
    "A bounded height domain is a partially ordered set <%D%> equipped with a number <%b%> such that every increasing chain <%x_1 LEQ %{ldots}% LEQ x_n%> in <%D%> with <%n GT b%> has a pair <%x_i GEQ x_j%> with <%i LT j%> (equivalently, for every <%i LEQ k LEQ j%>, <%x_i = x_k%>)."}

Circuits will be given a semantics as increasing functions between such domains. To the extent that the material present in this section is different from the usual treatment it is to render this section constructive to be compatible with the topos of Section~{ref_ s_sequentialcircuits}. This is the reason why we focus on bounded height domains rather than the more usual <%omega%>-{textsc"cpo"}s. Note also that <%b%>, in Definition~{ref_ d_bhdomain} is {emph"not"} the height of the domain but rather an upper bound on this height. The reason is that, constructively, there may not be an exact height (see also~{cite"CoquandSpiwack2010"} for more thoughts on finiteness in constructive mathematics). Every proof, in this section, is constructive.

Bounded height domain have the fixed-point property, just like other kinds of domains. Note that the fixed-point property of {textsc"cpo"}s or <%omega%>-{textsc"cpo"}s are also constructive. The added value of bounded height domains is that there are really few constructive {textsc"cpo"}s or <%omega%>-{textsc"cpo"}s (see Remark~{ref_ r_omegacpos} below). Another practical advantage of bounded height domain is that the fixed-point property applies to all increasing functions, which will free us from proving continuity.

{theorem ~name:"Fixed-point property" ~label:t_bhfixpoint
    "Every increasing function <%f:D->D%> for a bounded height domain <%D%> with a smallest element <%Bot%> has a smallest fixed-point."
      ~proof:"Let <%b%> be a bound on the height of <%D%>. The sequence <%Bot LEQ f Bot LEQ f^2 Bot LEQ %{ldots}% LEQ f^b Bot%> has length <%b+1%>. By definition, there is an <%i LT b%> such that <%f^i Bot = f^\(i+1\) Bot%> hence <%f^b Bot = f^i Bot%> is a fixed point.

  It is the smallest since, by induction, for any fixed point <%x_0%> of <%f%> and every <%k%>, <%f^k Bot LEQ x_0%>.  "}

Remark that we can refine the proof to show that the least fixed point of <%f%> is also its least pre-fixed point ({foreign"i.e."} such that <%f x LEQ x%>).

Base types, which are sets, can be naturally identified to bounded height domains (without a smallest element).

{definition ~name:"Flat domains"
    "Given a set <%A%>, the partially ordered set (also noted <%A%>) where <%x LEQ y <=> x=y%> is a domain of height bounded by <%1%>, which we call a flat domain."}

Continuing on the subject of constructiveness, notice that flat domains are an example of domain which can't be assigned a height. Indeed, if <%A%> is inhabited then <%A%> has height <%1%>, whereas when <%A%> is empty then <%A%> has height <%0%> but it is not possible, in constructive mathematics to decide whether <%A%> is empty or not, the height flat domains is, therefore, not well defined (it is, in fact, impossible to define a non-constant integer-valued function on sets~{cite"Escardo2013"}).

In order to use base types in conjunction with the fixed point property they need a smallest element which we add freely.

{definition ~name:"Lifted domains"
    "Given a domain <%A%> with a bound <%b%> on its height, we construct a domain <%A_Bot%>, called {emph"lifted"}, by adding a distinguished element <%Bot%> to <%A%> and considering it smaller than every element of <%A%>: <%forall x:A, Bot LT x%>. The height of <%A_Bot%> is bounded by <%b+1%>"}

Wires in circuits will be interpreted as taking value in the lifted flat domains corresponding to base types. Increasing functions between lifted flat domain are such that if <%f Bot <> Bot%>, then for any <%a%>, <%f a = f Bot%>. In particular, if <%f%> is such a function with several fixed points, then <%f Bot = Bot%> and the smallest fixed point is <%Bot%>. So <%Bot%> represents both the absence of a well-defined fixed point and the presence of several fixed points.

Obviously, in order for the smallest fixed point of<%f%> to be non-<%Bot%>, <%f%> needs to ignore some of its input wires, for instance <%f%> could be the well-know parallel or:

{array [`C;`Vert;`C;`C;`C] [
  array_line ["<%por%>";"<%Bot%>";"<%0%>";"<%1%>"];
  midrule;
  array_line ["<%Bot%>" ; "<%Bot%>";"<%Bot%>";"<%1%>"];
  array_line ["<%0%>" ; "<%Bot%>";"<%0%>";"<%1%>"];
  array_line ["<%1%>" ; "<%1%>";"<%1%>";"<%1%>"];
]}

When one of the input of the parallel or is <%1%>, then the output is <%1%>, whatever the behaviour of the other input. In particular the following circuit is well defined (it outputs <%1%>):

{diagram_needed}

{remark ~label:r_omegacpos
    "Lifted flat domains are an example of bounded-height domains which are not necessarily {omega}-{textsc"cpo"}s, constructively. Indeed consider <%b1 = {0}%>, the singleton set, then <%b1_Bot%> is not constructively an {omega}-{textsc"cpo"}. An {omega}-chain in <%b1_Bot%> is an infinite sequence of <%Bot%> and <%0%> (such that after a <%0%>, every element is <%0%>). If an {omega}-chain has <%Bot%> as an upper bound, then all of its elements are <%Bot%>, if an {omega}-chain has <%0%> as an upper bound, at least one of its elements must be <%0%>{footnote"Accomplished constructive mathematicians may noticed that I have made use of Markov's principle in this statement: it's a valid thing to do, though since if something is unprovable from Markov's principle, it is certainly unprovable without. Alternatively, ``must'' in that sentence can be interpreted as the double-negation modality, in which case the statement is constructively true, and leads to a weaker, still non-constructive, version of the limited principle of omniscience."}. If every {omega}-chain had an upper bound, it would give a way to decide whether they contain a <%0%> or not, which is equivalent to the limited principle of omniscience: a known-to-be-non-constructive principle."}

To formalise circuits with multiple wires we remark that bounded height domains are closed by cartesian products.

{lemma ~name:"Cartesian product of domains"
    "The product <%A*B%> of two bounded height domains of respective bound <%b_A%> and <%b_B%>, with order <%(x_1,y_1) LEQ (x_2,y_2) <=> x_1 LEQ x_2 /\ y_1 LEQ y_2%> , is a domain whose height is bounded by <%b_A*b_B%>."
      ~proof:"A chain in <%A*B%> is simply a list of pairs <%(x,y)%>, with an constraint on consecutive pairs. However, chains can be represented differently as a list of pairs <%(x,l)%> with <%l%> a chain in <%B%>, with the intent that the pair <%(x,[y_1,%{ldots}%,y_n])%> represents the chain <%(x,y_1) LEQ %{ldots}% LEQ (x,y_n)%>. So that chains now have multiple representations depending on how successive pairs with the same first component are ``contracted''.

  We begin with the simplest representation where every pair <%(x,l)%> is an <%(x,[y])%>. Now, as long as our list is of size longer than <%b_A%> (without loss of generality we can suppose both <%b_A%> and <%b_B%> to be non-zero) we can use the fact that the first components describe a chain to find consecutive positions with the same <%x%> which we can contract. Hence strictly reducing the size of our list. This process gives us a contracted representation of the long chain of length <%b_A%> or less. But, since the total length of the chain is larger than <%b_A*b_B%>, there must be at least one second-component list with length larger than <%b_B%>. Applying the definition of the bound <%b_B%> to this list concludes the proof."}

Combinational gates are, therefore, interpreted as increasing functions of type <%A_1_Bot*%{ldots}%*A_n_Bot -> A_\(n+1\)_Bot*%{ldots}%*A_p_Bot%> (with each <%A_i%> being a base type). We call a gate <%g%> {emph"strict"} if it for any <%(x_1,%{ldots}%,x_n)%> where at least one of the <%x_i%> is <%Bot%> then <%g x_1%{ldots}% x_n = (y_1,%{ldots}%,y_p)%> where at least one of the <%y_i%> is <%Bot%>.

{section"Traced category" ~label:s_trace}

What is left is to use the fixed-point property to make precise the definition of feedback wires, the solution is given by Hasegawa~{cite"Hasegawa1997"~extra:"Theorem 3.1"} who gives a method to transform fixed-point operators into traces.

Traced categories~{citation_needed} provide a graphical language which is essentially the same as circuits with feedback. It is reassuring that circuits can be interpreted as arrows in such a traced category. It provides a natural equational theory on circuits which can be, among other things, leveraged to produce compilation schemes~{citation_needed}.

{lemma ~name:"Local fixed-point property"
    "Theorem~{ref_ t_bhfixpoint} can be extended to produce a local fixed point function: let <%f:A*X->X%> an increasing function (<%A%> and <%X%> bounded height domain with a smallest element), there is an increasing function <%mu f:A->X%>, such that for any <%a:A%>, <%\(mu f\) a%> is the least fixed point of the increasing function <%lambda x, f a x%>."
      ~proof:"The proof bulk of the proof is the same as Theorem {ref_ t_bhfixpoint}, taking into account that, by definition of cartesian product <%lambda x, f a x%> is, indeed, increasing: let <%b%> a bound on the height of X,
  <%\(mu f\) a = (lambda x, f a x)^b Bot%>.

We need to check the <%mu f%> is indeed increasing. But since <%f%> is increasing, for any <%a LEQ a'%> and any <%x LEQ x'%>  <%f a x LEQ f a' x'%>; by induction, we conclude that <%\(mu f\) a LEQ \(mu f\) a'%>."}

Hasegawa tells us that there are three properties to verify for a fixed point operator to yield a trace (note that, reciprocally, all traces in a cartesian category yield such a fixed point operator). We shall write <%MU a x, f a x%> instead of <%mu\(lambda (a,x), f a x\)%>. In addition and by definition, <%(MU a x, f a x) a_0 = MU x, f a_0 x%>; since the former is cumbersome, we will use the latter as a short-hand.

{lemma ~name:"Naturality in <%A%>"
  "For any <%f:A*X->X%> and <%g:B->A%>, the following holds: <%MU b x, f\(g b\) x = \(mu f\) COMP g%>."
  ~proof:"Let <%b:B%>, <%(MU b x, f\(g b\) x) b = MU x, f\(g b\) x%> is, by definition, the least fixed point of <%lambda x, f \(g b\) x%>. And, also by definition, so is <%\(mu f\) \(g b\)%>."}

{lemma ~name:"Naturality in <%X%>"
  "Let <%f%> be an increasing function in <%A*X->Y%>. For any <%g:Y->X%>, <%MU a x, g \(f a x\) = g COMP (MU a y, f a \(g y\))%>."
      ~proof:"Let us fix an <%a:A%>.
  {itemize [
    "Let us prove that <%g \(MU y, f a \(g y\)\)%> is a fixed point of <%\(lambda x, g \(f a x\)\)%>, and therefore <%MU x, g \(f a x\) LEQ g \( MU y, f a \(g y\) \)%>. This follows immediately from the fact that <%f a \(g \( MU y, f a \(g y\) \)\) = MU y, f a \(g y\) a%> and the fact that <%g%> is increasing.";
      "Conversely, we prove similarly that <%f a \(MU x, g \(f a x\)\)%> is a fixed point of <%lambda y, f a \(g y\)%>. This yields <%f a \(MU x, g \(f a x\)\) GEQ MU y, f a \(g y\) = f a \(g \( MU y, f a \(g y\) \)\)%>, and then, <%MU x, g \(f a x\) GEQ g \( MU y, f a \(g y\) \)%> by monotonicity of <%lambda x, f a x%>."
  ]}

  The two inequalities prove the lemma."}

{let inner = "<%MU x, f a x \(\(mu g\) a x\)%>" in
lemma ~name:"Bekič"
  "Let <%f:A*X*Y->X%> and <%g:A*X*Y->Y%>. Taking <%h:A->X%> to be <%h a = %{inner}%%>, the following holds <%MU a (x,y), (f a x y, g a x y) = lambda a, (h a , \(mu g\) a \(h a\))%>"
    ~proof:"For <%a:A%>, let us prove that <%(h a , \(mu g\) a \(h a\))%> is a fixed point of <%lambda (x,y), (f a x y, g a x y)%>.
  {displaymath @@ array [`L;`L;`L] [
    array_line [empty;"<%(f a \(h a\) \(\(mu g\) a \(h a\)\), g a \(h a\) \(\(mu g\) a \(h a\)\))%>"; empty];
    array_line [$=$;"<%(f a \(h a\) \(\(mu g\) a \(h a\)\), \(mu g\) a \(h a\))%>"; "(definition of <%mu g%>)"];
    array_line [$=$;"<%(h a, \(mu g\) a \(h a\))%>"; "(definition of <%h%>)"];
  ]}

  We also have that
  {displaymath @@ array [`L;`L] [
    array_line [empty;"<%MU (x,y), (f a x y, g a x y)%>"];
    array_line [ $=$; "<%(f a \(MU (x,y), (f a x y, g a x y)\) , g a \(MU (x,y), (f a x y, g a x y)\) )%>"];
  ]}

  This allows us to test both components for being fixed points or the corresponding function, which will suffice to conclude.

  {itemize [
    "<%f a \(MU (x,y), (f a x y, g a x y)\) GEQ h a%>: by definition of <%h%> it suffices to show that <%f a \(MU (x,y), (f a x y, g a x y)\)%> is a pre-fixed point of <%lambda x, f a x \(\(mu g\) (a,x)\)%>. After tedious calculations{footnote"So tedious, in fact, that I ended up formalising most of this section in the Coq proof assistant which, contrary to me, is not susceptible to calculation mistakes. Plus, I was getting lost and could use the help. This goes to prove that for certain mathematical proofs, proof assistant can be a productive way to develop proofs."}, it amounts to proving, calling <%(x_0,y_0) = \(MU (x,y), (f a x y, g a x y)\)%>, that <%MU y, g a x_0 y LEQ y_0%>. It is easily checked that <%y_0%> is a fixed point of <%lambda y, g a x_0 y%>, which concludes this sub-proof.";
    "<%g a \(MU (x,y), (f a x y, g a x y)\) GEQ \(mu g\) a \(h a\)%>. The argument is similar to above.";
  ]}  "}
"

let sequential = "{chapter"Sequential circuits" ~label:s_sequentialcircuits}

Adding time-sensitive gates forces to change the semantics. Sequential circuits are not to be seen as functions from (product of) base types to base types, but rather as functions from streams of base types to stream of base types. Unfortunately, the type <%A^bbN%> of streams of a finite height domain <%A%> is not a finite height domain in any useful way.

To be able to model feedback, a change a perspective will be needed. The typical approach to analysis of sequential circuits with feedback is to ``cut'' unit delays making their incoming wire into a special new output and the outgoing wire into a special new input. What makes this transformation even meaningful is the requirement that to compute a finite prefix of length <%n%> of a circuit's output, only a finite prefix of length <%n%> of the input is necessary. This requirement is called {emph"causality"}{footnote"It is possible to relax the requirement that input prefixes map to output prefixes of the precise same length. But no generality will be gained as the model presented in this section will be able to accommodate more general notions of causality {foreign"via"} stream transformations."}.

{section"Causal sets"}

With that in mind, it makes sense to see streams not as a whole, but as a progression of prefixes <%family n:bbN, A^n%>. All of the <%A^n%>, by virtue of being finite products of finite height domains, are finite height domains. A causal function can be then defined as a collection <%family n:bbN, f_n%> of functions <%A_n->B_n%> such that <%f_\(n+1\) \(w.a\)%> is of the form <%f_n w.b%>.

To abstract over these notions, let us introduce a topos~--~{foreign"i.e."} a model of constructive mathematics~--~where such a presentation of streams and causal functions is natural.

{definition ~name:"Causal sets"
    "The topos of {emph"causal sets"} is the topos of presheaves over the set of natural number with its standard ordering."}

This topos has been extensively studied by Birkedal, Møgelberg, Schwinghammer \& Støvring~{cite"DBLP:journals/corr/abs-1208-3596"} under the name {emph"topos of trees"} to contribute to the related problem of step-indexing. Their article can serve as a reference.

A causal set is, therefore, given by a family <%family n:bbN, A_n%> of sets together with {emph"restriction"} functions <%r_n:A_\(n+1\) -> A_n%>. Causal functions are families of functions <%family n:bbN, f_n%> such that <%r_n \(f_\(n+1\) a\) = f_n \(r_n a\)%>. Streams, seen, as above, as a progression of prefixes, form a causal set <%Stream A%> with <%(Stream A)_n = A^n%> and <%r_n \(w.a\) = w%>. Causal functions on <%Stream A%> are the same as defined above so that arrows in the topos of causal sets are, indeed, a generalisation of causal functions of streams.

(* arnaud: define the term `prefix' in the context of causal sets? *)

Topos are models of constructive mathematics, hence there is an interplay between {emph"internal"} statements of the topos of causal sets which are derived using the rules of constructive mathematics and {emph"external"} statements of ordinary mathematics. Internal statements are related to external statements via the Kripke-Joyal semantics~{cite"MacLaneMoerdijk1992"~extra:"Section VI.6"}: when <%phi%> is an internal proposition in context <%Gamma%> (<%Gamma%> is a (conjunction of) causal set giving sense to the free variables of <%phi%>), then for <%n IN bbN%> and <%alpha_n IN Gamma_n%> an external proposition <%n|=phi alpha_n%> is defined. The proposition <%n|=phi alpha_n%> means that <%phi%> holds at least until and including time <%n%> on <%alpha_n%>. The main property being that if <%phi%> is provable in constructive mathematics (usually written <%|-phi%>), then for all <%n%> and <%alpha_n%>, <%n|=phi alpha_n%>. And conversely, if <%phi%> is such that <%n|=phi alpha_n%> then <%phi%> is internally valid.

{section "Causal domains"}

Let us now endeavour to give an external description of internal bounded height domain, so as to show that <%Stream \(A_Bot\)%> is an internal bounded height domain for some base type <%A%>.

The ordering relation is reflexive: <%|-x LEQ x%>. That is, <%n|=alpha_n LEQ alpha_n%> for any <%n%> and <%alpha_n%>. In other words, a reflexive causal relation, is a family of reflexive relations on each sets of prefixes (compatible with restrictions). The same holds for symmetry and transitivity, such that an internal ordering relation is an ordering relation on each prefix{footnote"The reader may be worried about the implication in the statement of symmetry and transitivity, since the interpretation of implication is not direct in the Kripke-Joyal semantics. But it doesn't matter at ``toplevel'': <%|- x LEQ y -> y LEQ x%> translates to <%forall n alpha_n beta_n, forall \(k LEQ n\), k|=r^\(n-k\) alpha_n LEQ r^\(n-k\) beta_n -> k|= r^\(n-k\) beta_n LEQ r^\(n-k\) alpha_n%> which is equivalent to <%forall n alpha_n beta_n, n|=alpha_n LEQ beta_n -> n|=beta_n LEQ alpha_n%>."}.

(* arnaud: subscripts are often omitted in causal functions *)

The translation of ordering relations illustrate the purpose of causal sets: to make it possible to reason on finite prefixes of infinite data. This is, indeed, what we were looking for, to be able to use the fact that prefixes of <%Stream \(A_Bot\)%> are bounded height domains. We should expect, at this point, that internal bounded height domains are exactly those causal set where <%A_n%> is a bounded height domain for each <%n%>, which is indeed the essentially the case.

The key observation is that the casual <%List A%> which is the initial algebra of the functor <%A * X + 1%> can be defined as <%(List A)_n = List \(A_n\)%>. The restriction functions act pointwise on the elements of each list. Therefore, since subsets are taken pointwise {foreign"i.e."} <%\(compr x:A, phi x\)_n = compr x:A_n, phi_n x%>, chains internal to the topos of causal sets are chains on prefixes (compatible with restrictions).

Thanks to this observation, the internal definition of bounded height domain can be interpreted: <%b_n IN bbN%> is a bound on the height of <%A%> at time <%n%> if for all <%k LEQ n%>, <%b_n%> is a bound on the height of <%A_k%> in the ordinary sense. An internal domain <%A%> has a smallest element if each of the <%A_n%> has and restrictions map smallest elements to smallest elements.

{lemma "The causal set <%Stream \(A_Bot\)%>, for some ordinary set <%A%>, is a finite height domain with a smallest element internal to the topos of causal sets." ~proof:"Since the height <%(Stream \(A_Bot\))_n = A_Bot^n%> is bounded by <%2^n%>, which also bounds all the <%A_Bot^k%> for <%k LEQ n%>. The smallest element of <%A_n%> is <%(Bot,%{ldots}%,Bot)%>."}

As a consequence, we can build circuits as causal increasing functions <%Stream A_1_Bot*%{ldots}%*Stream A_n_Bot -> Stream A_\(n+1\)_Bot*%{ldots}%*Stream A_p_Bot%> and feedback wires can be interpreted as internal least fixed point like in Section~{ref_ s_combinationalcircuits}. The <%n%>-th prefix of a causal increasing function is a sequence <%family \(i LEQ n\), \(f_i IN A_i->B_i\)%> each of the <%f_i%> being increasing, and such that <%r_i\(f_\(i+1\) a\) = f_i\(r_i a\)%>.

What remains to be figured out is what a fixed point internal to the topos of causal set is. The internal formula for a fixed point is <%f a = a%> which translates to <%f_n a_n = a_n%> for any <%n%> (note that <%f%>, being an internal function, {foreign"i.e."} an element of <%A^A%>, has prefixes <%family \(i LEQ n\), \(f_i IN A_i->B_i\)%>, so <%f_n IN A_n -> A_n%>). Therefore the internal fixed point may is a fixed point at each prefix.

{section"Lifting traces"}

The results of the above section, while elegant, do not demonstrate effectively the usefulness of the topos-theoretic semantics: indeed, the treatment of the previous section could have been carried out directly just as easily without requiring topos-theoretic baggage. However, when all this material is developed, it becomes possible to easily lift more powerful theorems directly from the combinational semantics. Let us apply this principle to Hasegawa's theorem from Section~{ref_ s_trace}.

Hasegawa's theorem being an external statement about categories, we will have to translate the statement (but, crucially, not the proofs) of all four lemmas and show that they correspond to the hypotheses of Hasegawa's theorem.
"

(* arnaud: come back on strict gates: consider elaborating on well-formed sequential circuits then proof-read original statement. *)
(* conclusion: syntax, Jaber/Sozeau/Tabareau, well-formedness?(if not in main body) *)

let packages = [
  "inputenc" , "utf8" ;
  "fontenc" , "T1" ;
  "textcomp", "";
  "microtype" , "" ;
]

let prelude = concat_with_sep [
  (* Mis ici pour rester le plus "en dernier" possible. Plus d'options à mettre
     à l'avenir, en particulier pour configurer le style des liens*)
  command \"usepackage\" [T,"hyperref"] T ;
  input "style.tex";
  command \"bibliographystyle\" [T,"plain"] T;
  declare_theorems;
] par

let title = "Circuits via topoi"
let author = "Arnaud Spiwack"

let titling = concat [
  command \"title\" [T,title] T;
  command \"author\" [T,author] T;
  maketitle;
]

let doc = concat [
  titling;
  abstract;
  intro;
  combinational;
  sequential;
  command \"bibliography\" [A,"library"] A;
]

let file = \"topocircuit.tex\"

let options =
  [ "a4paper" ;
    "article" ;
  ]

let _ =
  try
    emit ~file (document ~options
                         ~prelude
                         ~packages
                         doc)
  with e -> Printexc.print_backtrace stdout; raise e

  (* arnaud: rafiner les modes plus tard *)
let _ =
  Mlpost.Defaults.set_prelude
      \"axhurkens.tex\"

let _ =
  Mlpost.Defaults.set_required_files [
    \"style.tex\"
  ]

let _ = match Arg.mode with
	 | `Cairo -> Mlpost.Cairost.dump_pdf ()
	 | `Mps -> Mlpost.Mps.dump ()
	 | _ -> assert false
